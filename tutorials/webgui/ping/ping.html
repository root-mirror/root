<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="utf-8">
    <title>RWebWindow latency test</title>
    <script src="jsrootsys/scripts/JSRoot.core.js" type="text/javascript"></script>
  </head>

  <body>
     <button onclick="SendMsg('halt')">Halt</button>
     <p>Main: <b id="output">Msg</b></p>
     <div id="clients"></div>
  </body>

  <script>

    class PingPongHandler {
       constructor(is_main, out_id) {
          this.is_main = is_main;
          this.out_id = out_id || "output";
          this.handle = null;
          this.last_ping = 0;
          this.sum = [0, 0, 0];
       }

       setOutput(msg) {
          let elem = document.getElementById(this.out_id);
          if (elem) elem.innerHTML = msg;
       }

       // method called when connection established
       onWebsocketOpened(handle) {
          this.handle = handle;
          this.setOutput("Connected");
          if (this.is_main)
             this.handle.send("first"); // request for configuration
          this.sendPing();
          this.configInterval(3000);
       }

       // method with new message from server
       onWebsocketMsg(handle, msg, offset) {
          if (typeof msg != "string") {
             // let arr = new Float32Array(msg, offset);
             // AddOutput("bin: " + arr.toString());
          } else if (msg.indexOf("PING:") == 0) {
             this.processPing(msg.substr(5));
          } else if (msg.indexOf("CLIENTS:") == 0) {
             let nclients = parseInt(msg.substr(8));
             if (this.is_main && (nclients > 1))
                this.startMoreClients(nclients-1);
           }
       }

       // method called when connection is gone
       onWebsocketClosed(handle) {
          this.handle = null;
          this.configInterval(0);
          // when connection closed, close panel as well
          if (window) window.close();
       }

       // configure periodic handler
       configInterval(msec) {
          if (this.interval) {
             clearInterval(this.interval);
             this.interval = null;
          }
          if (!msec) return;

          this.interval = setInterval(() => {
             let tm = new Date().getTime();
             if (tm - this.last_ping > 2000)
                this.sendPing();
          }, msec);
       }

       // periodical handler
       sendPing() {
          let tm1 = new Date().getTime();
          this.last_ping = tm1;
          if (this.handle)
             this.handle.send("PING:" + tm1);
       }

       processPing(msg) {
          let tm1 = parseInt(msg);
          let tm2 = new Date().getTime();
          let diff = tm2 - tm1;

          this.sum[0]+=1;
          this.sum[1]+=diff;
          this.sum[2]+=diff*diff;

          let mean = this.sum[1] / this.sum[0], dev = "";

          if (this.sum[0] > 5) {
             dev = this.sum[2] / this.sum[0] - mean*mean;
             dev = (dev > 0) ? Math.sqrt(dev) : 0;
          }

          let v = "Cnt: " + this.sum[0];
          v += " round-trip: " + mean.toFixed(1);
          if (dev > 0) v += "&plusmn;" + dev.toFixed(0);
          v+= " ms";
          this.setOutput(v);

          this.sendPing();
       }

       startMoreClients(nclients) {
          let html  = "";
          for (let n = 0; n < nclients; ++n)
             html += `<p>Client${n+1}:  <b id='out${n}'>output</b></p>`;
          document.getElementById("clients").innerHTML = html;

          for (let n = 0; n < nclients; ++n) {
             let sub_handler = new PingPongHandler(false, "out" + n);
             JSROOT.connectWebWindow( { receiver: sub_handler, socket_kind: this.handle.kind } );
          }
       }
    }

    let main_handler = new PingPongHandler(true);

    function SendMsg(txt) {
       if (main_handler && main_handler.handle)
          main_handler.handle.send(txt);
    }

    // important this line, which need to be specially handled
    // line MUST always end with "({" symbols
    JSROOT.connectWebWindow({
       receiver: main_handler
    });

  </script>

</html>
